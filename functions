#
# bashrc/functions
#

# tryhard ()
#
# tryhard mode: activated
#
# tries common places for when I forget to type the start
# of a path. 'tryhard cd etc` becomes 'cd /etc` and
# 'tryhard vim .bashrc` works from anywhere
#
# Usage: tryhard CMD TARGET
#
# cutejs (Astrid Fesz-Nguyen)
# 2019-02-14

tryhard () {

  local FILES=1
  local DIRS=1
  local RECURSE=0
  local VERBOSE=0
  local GLOB=0

  local -a _TRY_COMMON=("$HOME" "/")
  local -a _TRY_CFG=("/etc")
  local -a TRY

  [[ -e $HOME/.tryhardrc ]] && source $HOME/.tryhardrc

  OPTIND=1
  while getopts "fdaD:ceurgvVh" OPT; do
    case $OPT in
      f) FILES=1; DIRS=0 # files
	;;
      d) FILES=0; DIRS=1 #directories
        ;;
      a) FILES=1; DIRS=1 # all
        ;;
      D)
        TRY=("${OPTARG[@]}")
        ;;
      c)
        TRY+=("${_TRY_COMMON[@]}")
        ;;
      e)
	TRY+=("${_TRY_CFG[@]}")
        ;;
      u)
        TRY+=("..")
	;;
      r)
	RECURSE=1
        [[ ! $TRY ]] && TRY=(".")
	;;
      g)
        GLOB=1
        ;;
      v)
        VERBOSE=1
        ;;
      V)
        VERBOSE=2
        ;;
      h)
        cat <<EOF
usage: tryhard CMD TARGET

  Options:
    -f       TARGET should be a file
    -d       TARGET should be a directory
   [-a]      TARGET may be a file or a directory
   [-c]      Search in common places (by default . ~ and /)
    -e       Search in configuration places (by default /etc)
    -u       Search up one parent directory
    -r       Recursively search. If search directory is not explicitly
              provided, starts in current working directory
    -g       Adds a glob star to the end of TARGET
    -D DIR   Use DIR as base search directory
    -v       Prints full path of resolved target
    -V       Prints full path of resolved target and debug information
    -h       Print this help message

  Files:
    ~/.tryhardrc Specify default directories to search by setting
    _TRY_COMMON for -c (default) and _TRY_CFG for -e flags

EOF
	;;
      ?)
	# moving on
	;;
     esac
  done
  shift $(($OPTIND - 1))

  [[ ! $TRY ]] && TRY=( "${_TRY_COMMON[@]}" )

  local CMD=${@:1:$#-1}
  local TARGET="${@:$#}"
  local DONE=

  [[ ! $TARGET ]] && {
    $CMD
    return $?
  }

  _try () {
    for T in $@ ; do
      TT="${TARGET} ${T}/${TARGET}"
      # "//" just kind of bugs me lol
      [[ $T == "/" ]] && TT="/$TARGET"
      (( $GLOB )) && TT="${TT}*"
      (( $VERBOSE >= 2 )) && {
        echo "DEBUG T $T"
        echo "DEBUG TT $TT"
      }
      for TG in $TT ; do
		(( $VERBOSE >= 2 )) && echo "DEBUG TG $TG"
        if (( $DIRS )); then
          if [[ -d "$TG" ]]; then
            (( $VERBOSE )) && [[ $TG != $TARGET ]] && echo "$TG"
            $CMD "$TG"
            DONE=$?
            return $DONE
          fi
        fi
        if (( $FILES )); then
          if [[ -f "$TG" ]]; then
            (( $VERBOSE )) && [[ $TG != $TARGET ]] && echo "$TG";
            $CMD "$TG"
            DONE=$?
            return $DONE
          fi
        fi
      done
      if (( $RECURSE )); then
        local -a SUBS
        if [[ -d $T ]]; then
          SUBS+=("$T/*/")
          _try "${SUBS[@]}"
          [[ $DONE ]] && return $DONE
        fi
      fi
    done
  }

  _try "${TRY[@]}"
  [[ $DONE ]] && return $DONE

  # didn't find it; let CMD print an appropriate error message
  $CMD "$TARGET";
}

# inception ()
#
# A shell within a shell within a...
#
# Returns 0 if not in a subshell, otherwise prints depth
# and returns that number as an error code
#
# cutejs (Astrid Fesz-Nguyen)
# 2019-01-21

inception () {
  local SHLVL=$(($SHLVL - 1))
  (( $SHLVL == 0 )) || echo "$SHLVL>"
  return $SHLVL
}

# ok? ()
#
# ok desuka?
#
# boo I used to be able to call this ok? but it
# gets mad now
#
# Forwards exit code of last executed command
# prints the code and an error message if not 0
#
# Usage: $ <TEST_CMD> ; ok? [MESSAGE...]
#
# cutejs (Astrid Fesz-Nguyen)
# 2019-01-21

ok () {
  local OK=$?
  if (( $# )); then
    local MSG="$*"
  else
    local MSG='not ok'
  fi

  if (( $OK != 0 )); then
    echo $OK
    echo $MSG 1>&2
  fi
  return $OK
}

# Hacky way to check if current shell is a tty.
# Really we should also check inception but w/e
is_tty () {
  local TTY_REGEX='^/dev/tty[0-9]+'
  if [[ `tty` =~ $TTY_REGEX ]]; then
    return 0
  else
    return 1
  fi
}

# cd+ ()
#
# one of those rare, mysterious 800MB CDs you can never find anymore
#
# Usage: drop in replacement for cd
#
# Environment: Relies on $_CD_MOD_PRE and $_CD_MOD_POST variables
# for configuration. Prefixes cd+ command with PRE variable @-expanded
# and then runs commands in $_CD_MOD_POST. Commands are separated by --
#
# cutejs (Astrid Fesz-Nguyen)
# 2019-02-15

cd+ () {
  local -a PRE
  local -a POST
  local DEST=~
  [[ $1 ]] && DEST="$1"
  [[ _CD_MOD_PRE ]] && PRE+=(${_CD_MOD_PRE[@]})
  [[ _CD_MOD_POST ]] && POST+=(${_CD_MOD_POST[@]})

  ${PRE[@]} cd "$DEST" && {
    local -a CMD
    local DONE=
    for FRAG in ${POST[@]} ; do
      if [[ "$FRAG" != '--' ]] ; then
        CMD+=("$FRAG")
      else
        ${CMD[@]} || DONE=$?
        [[ $DONE ]] && return $DONE
        CMD=()
      fi
    done
	[[ $CMD ]] && ${CMD[@]}
  } 
}

#
# cdmod ()
#
# Turn it up a notch!
#
# 2019-02-14
# cutejs (Astrid Fesz-Nguyen)
cdmod () {
  local -a PRE=()
  local -a POST=()
  PRE+=(${_CD_MOD_PRE[@]})
  POST+=(${_CD_MOD_POST[@]})
  local VAR=
  for ARG ; do
    case $ARG in
      '-l')
        echo '$_CD_MOD_PRE'
        echo ${_CD_MOD_PRE[@]}
        echo '$_CD_MOD_POST'
        echo ${_CD_MOD_POST[@]}
        return 0
        ;;
      '-p')
        VAR=pre
        PRE=()
	;;
      '-P')
        VAR=post
        POST=()
        ;;
      '-h')
        cat <<EOF
usage: cdmod [-p|P] MODS... [ [-p|P]] MODS... ]

Nice way to build $_CD_MOD_PRE and $_CD_MOD_POST environment variables
for use with cd+ function.

  Options:
    -p MODS...  Save all subsequent arguments to prefix mod (excepting -P)
    -P MODS...  Save all subsequent arguments to post mods
    -h          Print this help message

EOF
        return 0
        ;;
      *)
        # escape hatch in case you need to send a literal -p or -P
        [[ $ARG == "'-p'" ]] && ARG="-p"
        [[ $ARG == "'-P'" ]] && ARG="-P"

        case $VAR in
          pre)
            PRE+=("$ARG")
            ;;
          post)
            POST+=("$ARG")
            ;;
          *)
            echo Not sure what you are trying to modify
            echo Use -h option for usage.
            return 1
            ;;
        esac
        ;;
    esac
  done

  export _CD_MOD_PRE=( ${PRE[@]})
  export _CD_MOD_POST=( ${POST[@]})
}

cat_or_ls () {
  # this admittedly acts weird if you typed just 'cat`, but I can just use $CAT
  if [[ ! $1 ]] || [[ $1 = -* ]]; then
    $LS "$@"
  elif [[ -d $1 ]]; then
    $LS "$@"
  elif [[ -f $1 ]]; then
    $CAT "$@"
  else
    echo "$1: Not a file or directory" 1>&2
    return 127
  fi
}

lib: () {
  local -a TRY=("$HOME/lib" "$HOME/src")
  tryhard -D "$HOME/lib" ls $1
}

#(Disc|C)harging, 

_bat_match () {
  [[ `acpi -i` =~ (Discharging|Charging|Unknown|Not charging),\ ([0-9]{1,3})%.*(remaining|until\ charged|.) ]]
}

batcolor () {
  _bat_match
  local CHARGE=${BASH_REMATCH[1]}
  local NUM=${BASH_REMATCH[2]}
  # hardcoded to pink for now
  local COLOR=$'\033[1;35m'
  [[ $BASH_REMATCH ]] && {
    if [[ $CHARGE == Discharging ]]; then
      if (( $NUM <= 10 )); then
        COLOR=$'\033[1;31m'
      elif (( $NUM <= 42 )); then
        COLOR=$'\033[1;33m'
      else
        COLOR=$'\033[1;32m'
      fi
    elif [[ $CHARGE == 'Unknown' ]]; then
      COLOR=$'\033[0;35m'
    else
      if (( $NUM <= 75 )); then
        COLOR=$'\033[1;34m'
      fi
    fi
  }
  echo $COLOR
}

bat () {
  _bat_match
  local MSG=$BASH_REMATCH
  [[ ! $MSG ]] && MSG=`acpi -i`
  local RESET=$'\033[0m'

  echo `batcolor`${MSG}${RESET}
}
