#
# bashrc/functions
#

# tryhard ()
#
# tryhard mode: activated
#
# tries common places for when I forget to type the start
# of a path. 'tryhard cd etc` becomes 'cd /etc` and
# 'tryhard vim .bashrc` works from anywhere
#
# Usage: tryhard CMD TARGET
#
# cutejs (Astrid Fesz-Nguyen)
# 2019-02-14

tryhard () {

  local FILES=1
  local DIRS=1
  local RECURSE=0
  local VERBOSE=0
  local GLOB=0
  local MULTI=0

  local -a _TRY_COMMON=("$HOME" "/")
  local -a _TRY_CFG=("/etc")
  local -a TRY

  [[ -e $HOME/.tryhardrc ]] && source $HOME/.tryhardrc

  OPTIND=1
  while getopts "fdaD:ceuUrgmvVh" OPT; do
    case $OPT in
    f) FILES=1; DIRS=0 # files
      ;;
    d) FILES=0; DIRS=1 #directories
      ;;
    a) FILES=1; DIRS=1 # all
      ;;
    D)
      TRY=("$OPTARG")
      ;;
    c)
      TRY+=("${_TRY_COMMON[@]}")
      ;;
    e)
      TRY+=("${_TRY_CFG[@]}")
        ;;
    u)
      TRY+=("..")
      ;;
    U)
      TRY+=(".." "../.." "../../..")
      ;;
    r)
      RECURSE=1
      [[ ! $TRY ]] && TRY=(".")
      ;;
    g)
      GLOB=1
      ;;
    m)
      MULTI=1
      ;;
    v)
      VERBOSE=1
      ;;
    V)
      VERBOSE=2
      ;;
    h)
      cat <<EOF
usage: tryhard CMD TARGET

  Options:
    -f       TARGET should be a file
    -d       TARGET should be a directory
   [-a]      TARGET may be a file or a directory
   [-c]      Search in common places (by default . ~ and /)
    -e       Search in configuration places (by default /etc)
    -u       Search up one parent directory
    -U       Search up to 3 levels of parent directories
    -r       Recursively search. If search directory is not explicitly
              provided, starts in current working directory
    -g       Adds a glob star to the end of TARGET
    -D DIR   Use DIR as base search directory
    -m       Perform CMD on all found TARGETs rather than stopping at the first one
    -v       Prints full path of resolved target
    -V       Prints full path of resolved target and debug information
    -h       Print this help message

  Files:
    ~/.tryhardrc Specify default directories to search by setting
    _TRY_COMMON for -c (default) and _TRY_CFG for -e flags
EOF
      ;;
    ?)
  # moving on
      ;;
    esac
  done
  shift $(($OPTIND - 1))

  [[ ! $TRY ]] && TRY=( "${_TRY_COMMON[@]}" )

  local CMD=${@:1:$#-1}
  local TARGET="${@:$#}"
  local DONE=

  [[ ! $TARGET ]] && {
    $CMD
    return $?
  }

  _try () {
    for T in $@ ; do
      TT="${TARGET} ${T}/${TARGET}"
      # "//" just kind of bugs me lol
      [[ $T == "/" ]] && TT="/$TARGET"
      (( $GLOB )) && TT="${TT}*"
      (( $VERBOSE >= 2 )) && {
        echo "DEBUG T $T" 1>&2 
        echo "DEBUG TT $TT" 1>&2
      }
      for TG in $TT ; do
        (( $VERBOSE >= 2 )) && echo "DEBUG TG $TG" 1>&2
        if (( $DIRS )); then
          if [[ -d "$TG" ]]; then
            (( $VERBOSE )) && [[ $TG != $TARGET ]] && echo "$TG" 1>&2
            $CMD "$TG"
            DONE=$?
            (( $MULTI )) || return $DONE
          fi
        fi
        if (( $FILES )); then
          if [[ -f "$TG" ]]; then
            (( $VERBOSE )) && [[ $TG != $TARGET ]] && echo "$TG" 1>&2
            $CMD "$TG"
            DONE=$?
            (( $MULTI )) || return $DONE
          fi
        fi
      done
      if (( $RECURSE )); then
        local -a SUBS
        if [[ -d $T ]]; then
          SUBS+=("$T/*/")
          _try "${SUBS[@]}"
          (( $MULTI )) || {
            [[ $DONE ]] && return $DONE
          }
        fi
      fi
    done
  }

  _try "${TRY[@]}"
  [[ $DONE ]] && return $DONE

  # didn't find it; let CMD print an appropriate error message
  $CMD "$TARGET";
}

# tryfind ()
#
# like find or locate but using tryhard mechanics
# 
# Usage: tryfind [OPTIONS] TARGET [...TARGETS]
#
# (shoutouts to GNU sort <3)
#
# cutejs (Astrid Fesz-Nguyen)
# 2019-08-20

tryfind () {
  local TYPE=
  local BASEDIR=
  local MULTI="-m"
  local RECURSE="-r"
  local GLOB=
  local UP=
  local VERBOSE=
  OPTIND=1
  while getopts "fdaD:1RguUvVh" OPT; do
    case $OPT in
      f) TYPE="-f" ;;
      d) TYPE="-d" ;;
      a) TYPE="-a" ;;
      D) BASEDIR="-D $OPTARG";;
      1) MULTI="" ;;
      g) GLOB="-g" ;;
      R) RECURSE="" ;;
      v) VERBOSE="-v" ;;
      V) VERBOSE="-V" ;;
      h) cat <<EOF
Usage: tryfind [options] TARGET [...TARGETS]

Options:
  -f   Search only for files
  -d   Search only for directories 
  -D   Base directory to search in
  -1   Only return first match
  -R   Do not recursively search subdirectories 
  -g   Add globstar to the end of filename
  -u   Also search directory above
  -U   Also search up to 3 directories above
  -v   Print all search paths 
  -h   Print this help message

See also: tryhard on which this is based
EOF
      return 0
      ;;
    ?)
      ;;
    esac
  done
  shift $(($OPTIND -1))

  local FLAGS="$TYPE $MULTI $RECURSE $GLOB $VERBOSE"

  tryhard "$BASEDIR" $FLAGS ls -d -1 "$@" | sed 's/[ \t]*$//' | sort -u
}

# try ()
#
# once more, with feeling
#
# convenience command for rerunning command
#
# Usage: try <again|harder|less>
#
try () {
  LASTCMD=`history | tail -2 | head -1 | sed 's/^ *[0-9]*//'`
  echo $LASTCMD
  if [[ $1 == "again" ]]; then
    tryhard -r -g $LASTCMD
  elif [[ $1 == "harder" ]]; then
    tryhard -g $LASTCMD
  elif [[ $1 == "less" ]]; then
    ($LASTCMD --color=always || $LASTCMD) | less -R
  else
    tryhard $LASTCMD
  fi
}

# inception ()
#
# A shell within a shell within a...
#
# Returns 0 if not in a subshell, otherwise prints depth
# and returns that number as an error code
#
# cutejs (Astrid Fesz-Nguyen)
# 2019-01-21

inception () {
  local SHLVL=$(($SHLVL - 1))
  (( $SHLVL == 0 )) || echo "$SHLVL>"
  return $SHLVL
}

# ok? ()
#
# ok desuka?
#
# boo I used to be able to call this ok? but it
# gets mad now
#
# Forwards exit code of last executed command
# prints the code and an error message if not 0
#
# Usage: $ <TEST_CMD> ; ok? [MESSAGE...]
#
# cutejs (Astrid Fesz-Nguyen)
# 2019-01-21

ok () {
  local OK=$?
  if (( $# )); then
    local MSG="$*"
  else
    local MSG='not ok'
  fi

  if (( $OK != 0 )); then
    echo $OK
    echo $MSG 1>&2
  fi
  return $OK
}

# Hacky way to check if current shell is a tty.
# Really we should also check inception but w/e
is_tty () {
  local TTY_REGEX='^/dev/tty[0-9]+'
  if [[ `tty` =~ $TTY_REGEX ]]; then
    return 0
  else
    return 1
  fi
}

# cd+ ()
#
# one of those rare, mysterious 800MB CDs you can never find anymore
#
# Usage: drop in replacement for cd
#
# Environment: Relies on $_CD_MOD_PRE and $_CD_MOD_POST variables
# for configuration. Prefixes cd+ command with PRE variable @-expanded
# and then runs commands in $_CD_MOD_POST. Commands are separated by --
#
# cutejs (Astrid Fesz-Nguyen)
# 2019-02-15

cd+ () {
  local -a PRE
  local -a POST
  local DEST=~
  [[ $1 ]] && DEST="$1"
  [[ _CD_MOD_PRE ]] && PRE+=(${_CD_MOD_PRE[@]})
  [[ _CD_MOD_POST ]] && POST+=(${_CD_MOD_POST[@]})

  ${PRE[@]} cd "$DEST" && {
    local -a CMD
    local DONE=
    for FRAG in ${POST[@]} ; do
      if [[ "$FRAG" != '--' ]] ; then
        CMD+=("$FRAG")
      else
        ${CMD[@]} || DONE=$?
        [[ $DONE ]] && return $DONE
        CMD=()
      fi
    done
  [[ $CMD ]] && ${CMD[@]}
  } 
}

#
# cdmod ()
#
# Turn it up a notch!
#
# 2019-02-14
# cutejs (Astrid Fesz-Nguyen)
cdmod () {
  local -a PRE=()
  local -a POST=()
  PRE+=(${_CD_MOD_PRE[@]})
  POST+=(${_CD_MOD_POST[@]})
  local VAR=
  for ARG ; do
    case $ARG in
      '-l')
        echo '$_CD_MOD_PRE'
        echo ${_CD_MOD_PRE[@]}
        echo '$_CD_MOD_POST'
        echo ${_CD_MOD_POST[@]}
        return 0
        ;;
      '-p')
        VAR=pre
        PRE=()
  ;;
      '-P')
        VAR=post
        POST=()
        ;;
      '-h')
        cat <<EOF
usage: cdmod [-p|P] MODS... [ [-p|P]] MODS... ]

Nice way to build $_CD_MOD_PRE and $_CD_MOD_POST environment variables
for use with cd+ function.

  Options:
    -p MODS...  Save all subsequent arguments to prefix mod (excepting -P)
    -P MODS...  Save all subsequent arguments to post mods
    -h          Print this help message

EOF
        return 0
        ;;
      *)
        # escape hatch in case you need to send a literal -p or -P
        [[ $ARG == "'-p'" ]] && ARG="-p"
        [[ $ARG == "'-P'" ]] && ARG="-P"

        case $VAR in
          pre)
            PRE+=("$ARG")
            ;;
          post)
            POST+=("$ARG")
            ;;
          *)
            echo Not sure what you are trying to modify
            echo Use -h option for usage.
            return 1
            ;;
        esac
        ;;
    esac
  done

  export _CD_MOD_PRE=( ${PRE[@]})
  export _CD_MOD_POST=( ${POST[@]})
}

cat_or_ls () {
  # this admittedly acts weird if you call just `cat', but I can just use $CAT
  if [[ ! $1 ]] || [[ $1 = -* ]]; then
    $LS "$@"
  elif [[ -d $1 ]]; then
    $LS "$@"
  elif [[ -f $1 ]]; then
    $CAT "$@"
  else
    echo "$1: Not a file or directory" 1>&2
    return 127
  fi
}

vim_or_cd () {
  if [[ ! $1 ]]; then
  $EDITOR
  elif [[ -f $1 ]]; then
    $EDITOR "$@"
  elif [[ -d $1 ]]; then
  cd+ $1
  else
    echo "$1: Not a file or directory" 1>&2
    return 127
  fi
}

cd_or_vim () {
  if [[ ! $1 ]]; then
  cd+
  elif [[ -f $1 ]]; then
    $EDITOR "$@"
  else
  cd+ "$1"
  fi
}

lib () {
  local FOUND=`\
    tryhard -r ls lib 2>/dev/null ||\
    tryhard -U ls lib 2>/dev/null ||\
  `
  [[ $FOUND ]] && cd $FOUND
}

src () {
  local FOUND=`\
    tryhard -r ls src 2>/dev/null ||\
    tryhard -U ls src 2>/dev/null ||\
  `
  [[ $FOUND ]] && cd $FOUND
}

#(Disc|C)harging, 

_bat_match () {
  [[ `acpi -i` =~ (Discharging|Charging|Unknown|Not charging),\ ([0-9]{1,3})%.*(remaining|until\ charged|.) ]]
}

batcolor () {
  _bat_match
  local CHARGE=${BASH_REMATCH[1]}
  local NUM=${BASH_REMATCH[2]}
  # hardcoded to pink for now
  local COLOR=$'\033[1;35m'
  [[ $BASH_REMATCH ]] && {
    if [[ $CHARGE == Discharging ]]; then
      if (( $NUM <= 10 )); then
        COLOR=$'\033[1;31m'
      elif (( $NUM <= 42 )); then
        COLOR=$'\033[1;33m'
      else
        COLOR=$'\033[1;32m'
      fi
    elif [[ $CHARGE == 'Unknown' ]]; then
      COLOR=$'\033[0;35m'
    else
      if (( $NUM <= 75 )); then
        COLOR=$'\033[1;34m'
      fi
    fi
  }
  echo $COLOR
}

bat () {
  _bat_match
  local MSG=$BASH_REMATCH
  [[ ! $MSG ]] && MSG=`acpi -i`
  local RESET=$'\033[0m'

  echo `batcolor`${MSG}${RESET}
}

#
# bash/git integration that's "good enough"
#
# 2019-08-19

whatbranch ()  {
  git branch 2>/dev/null | grep -s --no-filename '*' || true
}
